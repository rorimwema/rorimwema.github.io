---
title: "About Me"
date: 2026-01-20T10:00:00+03:00
draft: false
---
I believe computers are simple. It's us humans who keep making them complicated.

I'm that programmer who reads programming language theory for fun and genuinely enjoys compiler design. While others debate framework-of-the-week, I'm deep in the ML family, OCaml is my daily driver, and yes, I use the type system to prevent bugs *before* they happen. 

### My Toolbox (Affectionately Overcomplicated)

**OCaml** — My comfort zone. Currently building a Lisp interpreter because apparently writing one language in another language isn't meta enough.

**Erlang** — For when I need processes that don't crash when I inevitably make mistakes. The "let it fail" philosophy speaks to me on a spiritual level.

**Elm** — JavaScript that is not shit. Type-safe frontend development; what a concept.

**Haskell** — I "cheat" with it. Building a search engine and pretending I understand monads. (I don't. Nobody does. We all just pretend.)

**The Art of Computer Programming** — Currently working through Knuth. Volume 4B is my gym membership—I keep paying for it but rarely show up.

### Philosophy

I admire **Mat Armstrong's** approach: solve the actual problem, ignore the hype, write code that makes sense six months later. Complexity is a bug, not a feature. If you need a diagram to explain your architecture, your architecture is wrong.

### Currently Building

- A Lisp interpreter in OCaml (because every programmer must go through this rite of passage)
- A search engine in Haskell (because crawling the web seemed easier than understanding Zettabyte-scale systems papers)

### The Goal

Uncomplicate things. Make programming accessible. Prove that elegant solutions exist—you just have to stop accepting messy ones.

---

*"The best code is the code you don't have to write. The second best is the code you write once and never touch again."*

---